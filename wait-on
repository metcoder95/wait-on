#!/usr/bin/env node

'use strict'

const fs = require('fs')
const path = require('path')

const minimist = require('minimist')
const waitOn = require('.')

const minimistOpts = {
  string: ['c', 'd', 'i', 's', 't', 'w', 'httpTimeout', 'tcpTimeout'],
  boolean: ['h', 'l', 'r', 'v'],
  alias: {
    c: 'config',
    d: 'delay',
    i: 'interval',
    l: 'log',
    r: 'reverse',
    s: 'simultaneous',
    t: 'timeout',
    v: 'verbose',
    w: 'window',
    h: 'help'
  }
}
const waitOnOpts = [
  'delay',
  'httpTimeout',
  'interval',
  'log',
  'reverse',
  'simultaneous',
  'timeout',
  'tcpTimeout',
  'verbose',
  'window'
]

;(async () => {
  const argv = minimist(process.argv.slice(2), minimistOpts)
  // if a js/json configuration file is provided require it
  const configOpts =
    argv.config != null ? require(path.resolve(argv.config)) : {}

  if (argv.help) {
    // help
    const help = fs.readFileSync(path.join(__dirname, 'help.txt'), 'utf8')
    console.log(help)
    process.exit(0)
  } else {
    // if resources are present in the command line then they take
    // precedence over those in the config file.
    if (argv._.length > 0) {
      configOpts.resources = argv._
    }

    for (const optName of waitOnOpts) {
      if (argv[optName] != null) {
        configOpts[optName] = argv[optName]
      }
    }

    try {
      await waitOn(configOpts)
      process.exit(0)
    } catch (error) {
      console.error(error)
      process.exit(1)
    }
  }
})()
